:showtitle:
:toc: left
:numbered:
:icons: font
:state: predraft
:revremark: State: {state}
:authors: Robert Mustacchi <rm@fingolfin.org>

= IPD 38 Signal Handling, Extended FPU State, ucontexts, x86, and You
{authors}

As of this writing, illumos does not properly preserve the extended x86
register state as part of signal handling. This issue is documented in
[15254 %ymm registers not restored after signal
handler](https://www.illumos.org/issues/15254). The main goals of this
IPD are:

* To explain the challenges that we're facing and give appropriate
  context.
* To explain improvements to observability and the steps to fix this
  particular problem.
* Discuss forthcoming features on x86 that make this more challenging
  and how that changes are approach.
* Provide guidance for what should be done on future ports and other
  systems.

== Background

To fully understand what's going on, it's worth understanding several
different pieces and mechanisms that exist in the system that are all
inter-related.

=== x86 FPU and its Endless Extensions

The x86 FPU and its state has a long and sordid history from its life as
a co-processor in the form of the Intel 80387 to its current state of
being a rather large vector processing unit. This is even being extended
by the addition of a full Matrix Processing extensions.

There have been multiple different ways to save and restore the state in
the FPU. Initially there was the `fsave`/`fnsave` instruction which
stored it in one format and handled the 80-bit FPU state. This was used
for a while and became part of the i386 System V ABI (more on that
later). The structure for this is the the
https://github.com/illumos/illumos-gate/blob/7b5987898994d86cd20e00dbf8c305dfbfbb8bea/usr/src/uts/intel/sys/fp.h#L178-L194[`struct
fnsave_state`] which looks like:

----
struct fnsave_state {
	uint16_t	f_fcw;
	uint16_t	__f_ign0;
	uint16_t	f_fsw;
	uint16_t	__f_ign1;
	uint16_t	f_ftw;
	uint16_t	__f_ign2;
	uint32_t	f_eip;
	uint16_t	f_cs;
	uint16_t	f_fop;
	uint32_t	f_dp;
	uint16_t	f_ds;
	uint16_t	__f_ign3;
	union {
		uint16_t fpr_16[5];	/* 80-bits of x87 state */
	} f_st[8];
};	/* 108 bytes */
----

Eventually, the FPU hit a series of extensions for both the MMX and XMM
instructions. This resulted in a new structure and a new series of
instructions. 8 128-bit registers were added that were called `%xmm0`
to `%xmm7`. This resulted in a new structure to save and restore the
state that covered both the traditional x87 FPU state from fnsave and
the new state with the `fxsave` instruction. This produced the [`struct
fxsave_state`](https://github.com/illumos/illumos-gate/blob/7b5987898994d86cd20e00dbf8c305dfbfbb8bea/usr/src/uts/intel/sys/fp.h#L201-L231).
This looks like:

----
struct fxsave_state {
	uint16_t	fx_fcw;
	uint16_t	fx_fsw;
	uint16_t	fx_fctw;	/* compressed tag word */
	uint16_t	fx_fop;
#if defined(__amd64)
	uint64_t	fx_rip;
	uint64_t	fx_rdp;
#else
	uint32_t	fx_eip;
	uint16_t	fx_cs;
	uint16_t	__fx_ign0;
	uint32_t	fx_dp;
	uint16_t	fx_ds;
	uint16_t	__fx_ign1;
#endif
	uint32_t	fx_mxcsr;
	uint32_t	fx_mxcsr_mask;
	union {
		uint16_t fpr_16[5];	/* 80-bits of x87 state */
		u_longlong_t fpr_mmx;	/* 64-bit mmx register */
		uint32_t __fpr_pad[4];	/* (pad out to 128-bits) */
	} fx_st[8];
#if defined(__amd64)
	upad128_t	fx_xmm[16];	/* 128-bit registers */
	upad128_t	__fx_ign2[6];
#else
	upad128_t	fx_xmm[8];	/* 128-bit registers */
	upad128_t	__fx_ign2[14];
#endif
} __aligned(16);	/* 512 bytes */
----

Importantly from the above definition you can see that it was changed in
amd64. The most notable change was the increase from 8 to 16 xmm
registers. AMD declared that part of the baseline for the amd64 ABI and
was used for a while.

==== Enter AVX and xsave

In Intel's Sandy Bridge based systems Intel started on a trend of
growing the FPU state. The 16 128-bit xmm registers became 16 256-bit
registers. You can guess where this is going by this point: Intel needed
a new save and restore mechanism again. This was introduced with the
`xsave` instruction. However, rather than make the structure a fixed
size, they actually did a bunch of additional work and created something
that has had the flexibility to actually withstand several generational
changes.

The xsave save area begins with the `fxsave_state`. It is then followed
by an xsave-specific header. The xsave header is followed by two 64-bit
bitfields. The first 64-bit bitfield is used to indicate which
subsequent structures are present and valid. Each structure begins at a
fixed offset. Those fixed offsets are described by CPUID. Effectively
what happens is that each state component in CPUID tells us what offset
it begins at and where it is found.

An important thing to realize is that these offsets **do** vary between
vendors and systems. For example if we look at a Sylake System that
supports AVX-512 and an AMD Genoa system that supports AVX-512, here are
the offsets of different features that we have in the kernel:

.Comparison of xsave offsets
[opts="header",cols=3]
|===
| Feature | AMD | Intel
| AVX | 0x240 | 0x240
| AVX-512 OpMask | 0x340 | 0x440
| AVX-512 Hi256 | 0x380 | 0x480
| AVX-512 Hi16 | 0x580 | 0x680
|===

The important thing is that these offsets are basically only known at
run-time, but once the CPU is started, they shouldn't change. This has
important implications for the observability design that we'll come back
to later.

While there are many possible features in the processor, the OS may only
have done enabling support for them. As such, there is a register called
`xcr0`, which is the extended control register. This is read and written
to with the `xgetbv` and `xsetbv` instructions, the latter of which is
restricted to CPL 0 (e.g. the kernel). This is used to constrain what
`xsave` and `xrstor` will perform. In particular, things are only saved
and restored if they're enabled in xcr0 and in the corresponding
instruction masks / valid state bits. This makes it so that even if a
user sets additional bits into an xsave state, they won't be saved or
restored unless they're something that is known.

With the introduction of xsave, the OS moved to using it for saving and
restoring the FPU state on context switch; however, we did not update
anything in the signal handling or /proc paths to account for this in
the various ABIs (again more ahead).

==== Supervisor vs. User and State Explosion

Since AVX was added several more bits have been defined here. These bits
cover a wide variety of use cases and notably a split has been
introduced. Originally there were only states that were meant to be used
in all privilege levels such as AVX or the MPX bound registers so
`xsave` operated just fine in all privilege levels.

In particular, Intel added supervisor-only states that relate to things
such as the Processor Trace, Hardware P-States, and more. Instead of
setting things in `xcr0` there is a `IA32_XSS` MSR that is used to
control these settings in a similar way. The system then has to execute
the `xsaves` instruction to get the supervisor states into the xsave
structure. The `xsaves` instruction will also look at the user
components in `xcr0`, making it a single stop shop for the kernel with
the wrinkle of using a compressed form factor we'll mention in a bit.

With the addition of all these components into the xsave state, there
were several different things that have happened. There was the
introduction of an `xsaveopt` instruction that tried to save user state
in an optimized way using processor tracking. It sometimes makes sense
to use, but we can't always use it (e.g. in rtld). The second thing that
was done was the addition of a compressed form.

The way that the compressed form work is that the normal fxsave data is
still there, followed by the bitfields that describe what is present. A
particular bit is used in the second uint64 bitfield that the structure
is compressed. At that point, rather than use the cpuid defined fixed
offsets in the structure, each bit that is present in the feature set
has its data placed contiguously. So if the xsave structure had say only
one bit marked present in the bitfield, even if its normal cpuid offset
would suggest it be at much further part in the structure, it'll be
placed first.

The compressed form uses the `xsavec` instruction to save the resulting
state. To restore state, the normal `xrstor` instruction can be used,
but it has slightly different behavior. The supervisor state has to be
restored with the `xrstors` instruction and more confusingly, the
supervisor state can only use the **compressed** form.

This difference is important to note as it leads to some trickiness that
we need to consider. illumos does not make use of the supervisor state
at this point in time; however, the supervisor state makes an
interesting wrinkle that needs to be considered: the normal flush of the
FPU today only really considers that it contains user state and we'll
need to make sure that when we're going to and fro that we're not
potentially clobbering supervisor state.

===== Comparing the xsave variants

Given all of the above, it's worth summarizing the variants. They all
have slightly different behaviors and keeping them straight are
confusing. Whenever we're saving and restoring there is something that
Intel calls the 'requested-feature bitmap' or RFBM. This is specified in
registers and basically acts as yet another filter in terms of what is
saved and restored. A bit has to be both in that, `xcr0` or `IA32_XSS`,
and when restoring, the actual structure. The following table attempts
to summarize high-level differences.

.Comparison of xsave familiy instructions
[opts="header",cols=4]
|===
| Instr | Compressed | Supervisor | Optimizations
| `xsave` | No | No | init
| `xsaveopt` | No | No | init, modified
| `xsavec` | **Yes** | No | init-mxcsr
| `xsaves` | **Yes** | **Yes** | init-mxcsr, modified
|===

Let's take these apart. What the init optimization basically says is
that if a given component is in what it defines as the default state,
then these things will no bother writing them out and will not set the
bit in the xsave header indicating its presence.

With the xsavec/xsaves style the init modification changes a bit.
Basically there is a bit of a semantic thing they tried to fix, but it's
a bit confusing. In particular, if someone has set the MXCSR value to
something other than 0x1f80, then it will dump the XMM state if we
requested it in the RFBM.

The modified extension is a little more spicy. What ends up happening is
that the processor begins tracking when state has been modified relative
to the last restore of data; however, it also tracks a bunch of
information about where that save occurred which includes the address of
the state, privilege level, whether you're in a vmx non-root context,
etc. Ultimately, what these are all trying to do is to make sure that if
you're saving / restoring into similar places (like say lwp's pcb) that
you don't have to do everything if nothing's changed. Now the flip side
of that, is that it means that if you change what's inside that state
without a subsequent restore or something else to invalidate this, then
you likely are going to break the modified optimization, at least
reading between the lines.

Let's now turn our attention to the restore instructions. There are
three primary cases that we want o consider. The first is what happens
to the fpu state in the processor if the state bit isn't in the RFBM.
Next, we ask ourselves what happens if bit is set in the RFBM and not in
the xsave state and then what happens if it's set for both.

The other thing we need to consider is which bitfields do they use. When
a compressed save is used, the xstate_bv fields are set, but the
compressed form appears to also use the xcomp_bv member bits to indicate
presence. First let's discuss normal, uncompressed `xrstor` which has
the following properties:

* Logically RFBM does a binary-AND with xcr0 to determine the effective
  RFBM.
* If RFBM[i] is zero, the component is ignored.
* If RFBM[i] is one, but xstate_bv[i] is 0, the initial state of the
  unit is set.
* If RFBM[i] is one and xstate_bv[i] is 1, then the state in the xsave
  structure is set in the processor.

When `xrstor` operates on a compressed form, its behavior changes
slightly. While compressed information is written into xcomp_bv, it
still uses xstate_bv mostly because it is an error for a bit to be set
in xstate_bv, but not xcomp_bv. In particular, here's what's different:

* If a bit is not in xstate_comp, it will not be restored. This is in
  addition to requiring the bit to be set in xstate_bv[i].
* If RFBM[1] is set and xstate_bv[1] is 0, the MXCSR is set to 0x1f80.
  Normal `xrstor` apparently always sets the MXCSR from the xsave area
  if either RFBM[1] or RFBM[2] are set.

`xrstors` is similar to the compressed form of `xrstor`. In fact, it is
an error to restore an uncompressed format. The following differences
from the compressed form of `xrstor` exist:

* Valid bits to update are taken from both `xcr0` and `IA32_XSS`.
* If illegal values are set in any supervisor state component or the
  MXCSR value, then it will cause a `#gp`.

As we go forward into the discussion of what to do in the kernel, keep
the following in mind, as the fact that `xsaves` and `xrstors` only
operate on the compressed form is important.

==== Enter the Matrix

All of this seemed fine, but Intel has been adding a series of
instructions titled 'Advanced Matrix Extensions' (AMX) which are coming
in Sapphire Rapids. The notable thing is that this adds a 2D register
set called a tile which are used for tile-based matrix multiplication.
The initial register file is actually quite big! The new xsave state
component bit 18 is called `XTILEDATA` and is 8 KiB because it's 8 tiles
of 16 rows of 64-bytes each.

Now, recall that with eager FPU which whether it's a good idea or not
was required to work around speculative execution issues, requires that
the entire FPU state is saved and restored around each context switch.
So this is adding a large 8 KiB area to the xsave area, which most folks
probably don't want to pay the cost for as it means folks have to
actually set aside an additional 8 KiB of save area per process.

To deal with that, Intel appears to have added a new MSR entitled
`IA32_XFD` which stands for an extended feature disable. This
effectively introduces a new lazy FPU where a `#nm` is generated and
another new MSR, `IA32_XF_ERR_MSR` can be used to determine which state
components were at fault. In Intel's initial version in Sapphire Rapids
the docs suggest that only the XTILEDATA will cause this to happen. The
docs also make a bunch of exceptions for what will generate a `#nm`. For
example, many `xsave` and `xrstor` family instructions will not cause
this to change.

While we don't support AMX today, it's worth understanding what this
means and we'll go into that into a bit more detail when we discuss the
solution space. The important take away is that the amount of register
space this covers is only growing. As part of this, it's worth calling
out that because this has even more dramatic challenges with the signal
stack size and just the sheer cost of tracking and preserving these, in
Linux, Intel and others are exploring this functional unit not being
enabled by default for a process unless it promises that it's ok to use
it.

This has been implemented through an architecture-specific prctl related
function that was introduced in https://lwn.net/Articles/874846/[Linux
5.16].

==== Performance Gotchas

When AVX and AVX-512 in particular is active the CPU may often slow down
its overall clock rate. The interesting question is what determines
activity. Here it's worth calling out to some historical issues here
such as https://www.illumos.org/issues/9596[illumos#9596 Initial xsave
xstate_bv should not include all features] and
https://www.illumos.org/issues/9595[illumos#9595 rtld should
conditionally save AVX-512 state]. The main point of these is to keep in
mind that misuse of states can lead to the processor slowing down even
if we're not using the extended state, but just the processor believing
it is valid. Though we expect that processors have gotten better from
those days.

=== System V Context Operations

There are a suite of functions and data structures that have
traditionally been used to manage what were called contexts. This
involves the types:

* `ucontext_t` -- a somewhat opaque, ABI defined structure that
  describes the user's overall context.

* `mcontext_t` -- a somewhat opaque, ABI defined structure that
  describes the hardware-specific portion of a context. It is generally
  embedded in the `ucontext_t`.

Related to this are a suite of four functions that are often used for
obtaining these states:

* https://illumos.org/man/2/getcontext[`getcontext(2)`] -- This is used
  to obtain a context about for the current thread.

* https://illumos.org/man/2/makecontext[`makecontext(2)`] -- This takes
  an existing context and modifies it so that when it is restored, it
  will be used to call a specified function that is part of its
  arguments.

* https://illumos.org/man/2/swapcontext[`swapcontext(2)`] -- This
  provides a way of calling into a new context while retrieving the
  current one in one fell-ish swoop.

* https://illumos.org/man/2/setcontext[`setcontext(2)`] -- This takes
  the specified context and it makes it the current reality. A function
  call to setcontext does not return in the conventional sense.

These functions all exist for building up a way of performing user-level
context switching without the kernel being involved in knowing about it.
However, there are a couple things that are worth calling out that make
these different from when the kernel traditionally swaps out what's
running on the CPU:

* The kernel is really interrupting a thread and therefore must save and
  restore **all** of its state.
* When calling one of these functions, it is treated as a function call
  from a calling convention sense (whether getting or setting state).
  You'll also note that `makecontext` starts you at a function call
  entry. This means, the basic calling conventions about what registers
  have to be preserved or not need to be honored.

You'll note above we called the `ucontext_t` and `mcontext_t` somewhat
opaque. These structures vary for each architecture and vary between
Operating Systems. While the very original i386 `ucontext_t` and
`mcontext_t` were defined in the System V i386 ABI Supplement, the same
was not done in the amd64 documents or the much more recent ARM draft
documents. Despite all that, applications do assume that they can peak
inside and modify these structures.

In the strictest sense, these are not opaque and the types are a
fundamental part of the ABI. For better or worse, the primary
`ucontext_t` structure on x86 (that is for both 32-bit and 64-bit
environments) looks like:

----
struct  ucontext {
        unsigned long   uc_flags;
        ucontext_t      *uc_link;
        sigset_t        uc_sigmask;
        stack_t         uc_stack;
        mcontext_t      uc_mcontext;
        long            uc_filler[5];   /* see ABI spec for Intel386 */
};
----

Note, that while the `uc_filler` currently has a comment in the source
code that suggests seeing the ABI spec, this filler has not been used.
This is an important thing! Let's briely discuss this structure. The
`uc_flags` member is used to indicate which other members are actually
valid and should be honored. There are flags that cover the signal mask,
the stack, CPU state, and FPU.

While this is the same on both architectures, the `mcontext_t` is quite
different because of the different registers that exist. The initial
`mcontext_t` structure is actually quite simple:

----
typedef struct {
        gregset_t       gregs;          /* general register set */
        fpregset_t      fpregs;         /* floating point register set */
} mcontext_t;
----

The `gregset_t` is actually just an array where the main difference is
how many registers are part of that state. The `fpregset_t` is where
things get interesting, nuanced, and is the true heart of darkness of
our problem.

The i386 version of the structure is phrased as what appears to be an
original `fnsave` style structure with a bunch of additional ways to
view the data. This was at some point in history amended to include the
8 xmm registers. It's not clear when that entered the actual i386 ABI
structure as it is not part of the original SCO ABI supplement.

The amd64 version however, is exactly the same as the fxsave_state (note
not `xsave`) with additional status words added on. This tied into the
default expectations of the ABI. All of this means that these functions
don't think about or handle anything related to `xsave`-based state.

It's an interesting question as to whether they can or cannot; however,
it makes it pretty hard to do based on the existing shape and
expectations of things like `getcontext(2)`. While the `uc_flags` member
is used to try to determine what is supposed to be considered valid and
not; however, it's pretty clear from the documentation that folks expect
most of the traditional default flags to be set and the kernel is not
meant to actually read the existing `uc_flags` member because is it
uninitialized stack garbage as part of a call to `getcontext(2)`. Put
differently, this is only valid in the context an initialized structure.

With this understanding of the context structures, let's go and dive
into everyone's favorite UNIX feature: signals!

=== Signals in the Dark

So where does all of the above collide: signal handling. Let's discuss
what happens on a signal and how illumos returns from a signal. Signal
handling has an important semantic: The signal handler basically has its
own register state and shouldn't be able to really change the register
state of the interrupted context (absent explicit action). In this
sense, it's much like a hardware interrupt or really like the kernel
opting to switch away to another thread.

So, how does this actually become reality? Every instruction set
architecture implements a `sendsig()` function in the kernel. This is
responsible for figuring out how to actually make a signal reality.
Signal handling is a joint cooperation between libc and the kernel.
Let's first go into what the kernel does when a signal is to be
delivered:

. The kernel looks at the singal's mask and disposition. If the signal
is masked, nothing really happens. If the signal's disposition is to
ignore it or to kill the process, then both of those things happen.
Let's assume we're delivering a signal.
. The next thing the kernel does is to determine whether or not the
signal should be delivered on the current stack or an alternate stack.
. It begins to construct a stack frame that varies between i386 and
amd64.
. The system saves the current thread's context with the equivalent of
the `getcontext(2)` system call.
. The entire `ucontext_t` structure is pushed onto the stack.
. Pointers to a `siginfo_t` are pushed on the stack (which itself may
already be there)
. The signal number is pushed onto the stack.
. A garbage return address is pushed onto the stack.
. It changes around the current registers that the process will resume
with changing things like:
* Making the stack pointer point to the signal stack.
* Changing the instruction pointer to map to whatever function libc had
  registered previously and giving it the appropriate arguments.
* Making sure that various segment registers, and other bits are set up
  to ensure reliable delivery.

Unlike some other kernel implementations, the `sigframe` and
`sigframe32` structures to not exactly cover the entire format (e.g.
they don't include the ucontext_t). After the context is saved and
everything is set up, the thread will copy everything out, and then
proceed to return to user land. If for some reason signal delivery
failed (e.g. invalid alternate stack pointer, stack overflow, etc.) the
kernel will proceed to instead kill the process.

When the signal comes to userland, we arrive in the main libc entry
point: `sigacthandler`. When a process calls
https://illumos.org/man/2/sigaction[`sigtaction(2)`] to register a
signal handler, libc stores that information itself and then registers
its own function as the entry point and there are a bit of things that
libc will do before calling the actual signal handler. Once the signal
handler has completed, then we will normally come back to this call and
libc will finally return to the original context calling `setcontext(2)`
on what it was given.

You'll note that we said that we only saved the `ucontext_t` above and
that the `ucontext_t` only actually contains the basic ABI state so on
amd64 in particular, this only has the original `fxsave` state. This is
exactly what leads to the issues that we saw
https://www.illumos.org/issues/15254[illumos#15254 %ymm registers not
restored after signal handler].

Applications though are actually allowed to change the `ucontext_t` on
the stack. That is, they know that they have a `ucontext_t` passed to
them in the signal handling function (assuming they filled out
`sa_sigaction`) and folks then do modify the context that they return
to. This actually happens with programs more than you might expect.
Consider the case of the Java Virtual Machine. When it has a
`NullPointerException`, that has in the past actually been the `SIGSEGV`
signal being handled.

While whether modifying state should or shouldn't be done may be a
reasonable question, the reality is that folks do and therefore we need
to consider this and this adds further cementing of the `ucontext_t` and
`mcontext_t` ABI.

==== Jumping Away

All this is fine, but there's more nuance here: one can actually return
out of a signal another way. You can actually use the
https://illumos.org/man/3C/siglongjmp[`siglongjmp(3C)`] family of
functions to leave things in a context of a signal handler. So what's
happening here? First, the `jmp_buf` is an opaque array that we just
happen to stuff a `ucontext_t` into. Fancy that. This is done in a
combination of assembler and C functions, but does not ultimately call
`getcontext(2)`.

It also does not actually obtain or save the floating point state! So
this means that jumping out of this state leaves the FPU in a rather
undefined state. In particular, we don't actually have `UC_FPU` set in
the context and thus we don't actually restore the FPU state to anything
and it is left as whatever it was when it was last used.

==== Sizing the Signal Stack

Traditionally, a combination of POSIX and System V standards have led
there to be definitions for the minimum and a default signal size used
for the stack. In particular, these constants have been:

`MINSIGSTKSZ` and `SIGSTKSZ` which is a recommend size. These
respectively have been 2 KiB and 8 KiB. While this was kind of ok in the
days of the original x86 `ucontext_t`, with the ever increasing size of
the `mcontext_t`, we need to think a bit more proactively here. In
particular, it can be possible that by the time all of the xsave state
is dumped to a stack, that it will not be able to handle the signal or
overflow an alternate signal stack.

There has been a bit of prior art in handling this. In particular, glibc
has gone and made these macros calls to
https://illumos.org/man/3C/sysconf[sysconf(3C)] in many situations. As
part of us evaluating the solution space, we will be exploring this in
more detail. But this is yet another piece of the puzzle.

=== /proc and Core File Observability

`/proc` is the main what the debuggers and the system have observability
about the state of registers in the system. This shows up in a bunch of
different places using the types of `prgregset_t` and `prfpregset_t`.
These structures are basically the exact same as their `mcontext_t`
compatriots of the `gregset_t` and `fpregset_t`, being all of a
`#define` in the x86-specific procfs headers.

Traditionally the registers for a thread are read out of its `lwpstatus`
file (i.e. `/proc/<pid>/lwp/<lwpid>/lwpstatus`). This provides a field
for both the general and floating point registers. In turn, registers
are set in a different way. Here, the `PCSREG` and `PCSFPREG` commands
are issued upon the `/proc/<pid>/lwp/<lwpid>/lwpctl` file determined by
a write. This is also abstracted by
https://illumos.org/man/3LIB/libproc[libproc(3LIB)] and its
corresponding functions such as
https://illumos.org/man/3PROC/Plwp_getregs[Plwp_getregs(3PROC)] and
https://illumos.org/man/3PROC/Plwp_setregs[Plwp_setregs(3RPOC)].

There are several additional files that exist in per-LWP directory in
`/proc` that cover different aspects of the process. In particular, one
of the files is the `xregs` file which is meant to contain extended
registers that are ISA-specific. There is a corresponding write
operation entitled `PCSXREG` that covers writing this and parts of
libproc.

The ELF notes that are used to make up core files follow a similar style
which are documented in https://illumos.org/man/5/core[core(5)].
Effectively, for every LWP we will write out a note with the contents of
the corresponding `prgregset_t`, `prfpregset_t`, and the `prxregset_t`.
Right now x86 doesn't have an `xregset` file or definition, so nothing
is written out there.
